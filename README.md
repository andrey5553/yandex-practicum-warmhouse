# Project_template

Это шаблон для решения проектной работы. Структура этого файла повторяет структуру заданий. Заполняйте его по мере работы над решением.

# Задание 1. Анализ и планирование

### 1. Описание функциональности монолитного приложения

**Управление отоплением:**

- Пользователи могут удалённо включать/выключать отопление, а также регулировать регулировать температуру в своих домах, данная возможность предоставляется через мобильное приложение.
- Система отправляет команды от сервера к датчикам управления в доме в синхронном режиме.

**Мониторинг температуры:**

- Система поддерживает получение данных о температуре с датчиков в домах от сервера в синхронном режиме.

### 2. Анализ архитектуры монолитного приложения

**Перечислите здесь основные особенности текущего приложения:** 

- Язык программирования: Go
- БД: PostgreSQL
- Архитектура: Монолит, все компоненты системы (обработка запросов, бизнес-логика, работа с данными) находятся в рамках одного приложения.
- Взаимодействие: Синхронное, пользователи не могут самостоятельно подключать устройства.
- Масштабируемость: Ограничена, так как монолит сложно масштабировать по частям.
- Развертывание: Требует остановки всего приложения, но в случаях низких требований к доступности и "zero-downtime", процесс деплоя не является узким местом. 

### 3. Определение доменов и границы контекстов

**Домены системы:**

1. Управление датчиками температуры отопления
2. Мониторинг температуры

Границы контекста:
1. Контекст - Управление датчиками температуры

- Входные точки:
- GET /sensors,
- GET /sensors/:id,
- POST /sensors,
- PUT /sensors/:id,
- PATCH /sensors/:id/value.
- DELETE /sensors/:id,

- External resources:
База данных PostgreSQL.

2. Контекст - Мониторинг температуры.

- Входные точки:ё
  GET /sensors/temperature/:location,
  GET /sensors/:id,
  (для температурных сенсоров).

- Внешние зависимости:
-   Внешний сервис REST API.

### **4. Проблемы монолитного решения**

  - Проблема масштабируемости, хотя можем попытаться увеличить количество реплик приложения.
  - Грубое нарушение SRP в модуле работы с датчиками температуры, в нем намешаны две разные ответственности, а именно логика получения температуры в помещениях логика работы с датчиками (должна быть только она).
  - В логике получения температуры в помещениях стоит использовать внешнюю зависимость от db и только, тем самым   выполнять логику получения информации о температуре непосредственно в данном сервисе без участия rest api.
  - Проблемы с надежностью и отказоустойчивостью, сбой в одной части приведет к остановке всего приложения.
  - Каждое обновление требует сборки/деплоя всего приложения, а также требует тестирования всего приложения после каждого обновления.
  - Отсутствие регистрации пользователя системе (нет такого модуля). Подключать новые дома должны специалисты и регистрировать их в системе (возможно есть админ апи для этого).
  - Невозможность подключения дополнительных устройств в рамках умного дома.
  - Синхронное управление датчиками, хотя опять же можно поиграть с репликами, но это дополнительная нагрузка.

### 5. Визуализация контекста системы — диаграмма С4

[Диаграмма as-is](schemas/as-is/as_is.puml)

# Задание 2. Проектирование микросервисной архитектуры

**Диаграмма контейнеров (Containers)**

[Containers](schemas/to-be/containers.puml)

**Диаграмма компонентов (Components)**
[Identity Service](diagrams/identity-service.puml)

**Диаграмма кода (Code)**

[Auth Code](schemas/to-be//uml-class-diagram/auth_component_sequence_diagram.puml)
[Devices Code](schemas/to-be//uml-class-diagram/device_service_classes.puml)
[Notification Code](schemas/to-be//uml-class-diagram/notification_service_routing.puml)
[Critical Telemetry Code](schemas/to-be//uml-class-diagram/telemetry_service_critical_flow.puml)

# Задание 3. Разработка ER-диаграммы

[ER](schemas/to-be//er-diagram/er-class-diagram.puml)

# Задание 4. Создание и документирование API

## 1. Тип API

### REST API для синхронного взаимодействия "запрос-ответ":

Обоснования:
- Для взаимодействие API с микросервисами (Authentification, Devices, Telemetry).
- Работа с HTTP-запросами от клиентов.

### Асинхронная коммуникация через брокер сообщений для событий:

Обоснования:
- Для уведомлений о событиях (переходим на событийную обработку между сервисами)
- Развязывает сервисы, повышает отказоустойчивость и позволяет обрабатывать события между сервисами

Гибридный подход (REST + Messaging) — это наиболее эффективный и часто применяемый способ построения отказоустойчивых микросервисных архитектур.

## 2. Документация API

[Auth Service](openapi/auth_service_openapi.yaml)
[Devices Service](openapi/device_service_openapi.yaml)
[Telemetry Service](openapi/telemetry_service_openapi.yaml)

# Задание 5. Работа с docker и docker-compose

1) Реализовано приложение temperature-api (написано на c# .net8.0).
[Директория приложения](apps/temperature-api/)

2) Приложение упаковано в Docker (см Dockerfile) и добавлен docker-compose, как отдельный , так и вынесено в основной docker-compose для основного приложения. Порт: 8081

3) Для smart_home приложения в docker-compose добавлена БД postgres с указанием скрипта инициализации ./smart_home/init.sql

Проверка: [Postman коллекция](apps/smarthome-api.postman_collection.json) и вызвать:

- Create Sensor
- Get All Sensors

При каждом вызове отображается разное значение температуры.

# **Задание 6. Разработка MVP**

# [Новый микросервис устройств](apps/device-service/)
Архитектура device-service в монолите
1. Поток данных устройств

┌─────────────┐      REST      ┌─────────────┐
│   Монолит   │ ──────────────> │  Device    │
│   (Go)      │                │  Service   │
│             │ <────────────── │  (Python)  │
└─────────────┘    Response    └─────────────┘
      │                              │
      │ PostgreSQL                   │ PostgreSQL
      ▼                              ▼
┌─────────────┐              ┌─────────────┐
│  Sensors    │              │  Devices    │
└─────────────┘              └─────────────┘

<img width="397" height="256" alt="image" src="https://github.com/user-attachments/assets/1f2a4665-8f1c-4f1b-98aa-44e0217ce55f" />


2. Ключевые компоненты интеграции
A. Клиент device-service (Go)

// Основные методы:
// - GetDevices() - получение списка устройств
// - CreateDevice() - создание устройства  
// - SendCommand() - отправка команды устройству

3. REST API endpoints device-service
  Получение всех устройств - GET /api/v1/devices
  Создание устройства - POST /api/v1/devices
  Отправка команды устройству POST /api/v1/devices/{id}/commands

4. Сценарии использования
  A. Управление устройствами через монолит
  # Пользователь включает свет через монолит
  POST http://localhost:8080/api/v1/devices/1/commands

  B. Получение списка устройств
  # Мобильное приложение запрашивает устройства
  GET http://localhost:8080/api/v1/devices

  C. Создание нового устройства
  # Админ добавляет новое устройство
  POST http://localhost:8080/api/v1/devices

# [Новый микросервис телеметрии](apps/telemetry-service/)
Архитектура telemetry-service в монолите
1. Поток данных телеметрии

┌─────────────┐    REST API    ┌──────────────────┐
│   Монолит   │ ──────────────>│ Telemetry Service│
│  (Go app)   │                │   (.NET 8.0)     │
│             │ <──────────────│                  │
└─────────────┘    Response    └──────────────────┘
       │                              │
       │ Database                     │ In-Memory Storage
       ▼                              ▼
┌─────────────┐                ┌──────────────────┐
│ PostgreSQL  │                │   Данные в RAM   │
│   Sensors   │                │  (временное)     │
└─────────────┘                └──────────────────┘

2. Клиент телеметрии (Go)
  Основные методы:
  - SendTelemetry() - отправка данных
  - GetDeviceTelemetry() - запрос данных
  - GetAggregatedHouseTelemetry() - агрегация

3. REST API endpoints telemetry-service
  POST /api/v1/telemetry - отправка телеметрии
  GET  /api/v1/telemetry/devices/{id} - получение телеметрии устройства  
  GET  /api/v1/telemetry/houses/{id}/aggregated - агрегированные данные

4. Сценарии использования
  Шаг 1: Обновление значения сенсора
  PATCH /api/v1/sensors/123/value
  Шаг 2: Монолит отправляет телеметрию асинхронно
  Шаг 3: Микросервис телеметрии принимает данные
  Шаг 4: Запрос телеметрии
    Клиент запрашивает историю телеметрии
	GET /api/v1/telemetry/devices/123?metric=sensor_value&aggregation=hour






    






